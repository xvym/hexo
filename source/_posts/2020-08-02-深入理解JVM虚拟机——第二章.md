---
title: 【阅读笔记】深入理解JVM虚拟机：第二章
date: 2020-08-02 23:39:54
tags: 
- JVM
- Java
categories: reading note
---
---
# **Java内存区域与内存溢出异常**
---
## *1.数据区域*
<!--more-->
### 1.1.运行时数据区域
- **线程共享**
    - *方法区(Method Area)*
        - 存储已被虚拟机加载的类型信息、常量、静态变量、JIT编译后的代码缓存等数据
        - 常量池表位于该区域
        - 无法满足新的内存分配需求时，抛出OOM异常
    - *堆(Heap)*
        - 在虚拟机启动时创建，存放几乎所有的对象实例，垃圾收集器GC就作用于此
        - 通过-Xmx和-Xms设定容量扩展
        - 当内存容量不足以完成对象实例化时，会抛出OOM异常
- **线程私有（生命周期与当前线程相同）**
    - *虚拟机栈(VM Stack)*
        - 每个方法被执行时，虚拟机会同步创建一个栈帧（StackFrame），存储一个方法执行时的变量表、操作数栈、动态链接、方法出口等信息
        - 每个方法被调用到执行完毕，就是一个栈帧从入栈到出栈的过程
        - 若方法调用过深，导致栈帧累计内存超过-Xss，会抛出SOF异常
        - 如果设置了栈内存动态扩展，当栈扩展超出内存容量时会抛出OOM异常
    - *本地方法栈（Native Method Stack）*
        - 与虚拟机机栈的作用类似，区别是虚拟机栈为虚拟机执行Java方法服务，本地方法栈为虚拟机使用到的本地方法（Native）服务
        - 异常抛出情况与虚拟机栈一致
    - *程序计数器（Program Counter Register）*
        - 当前线程所执行的字节码的行号指示器
        - 唯一一个不会OOM的区域

### 1.2.直接内存
- 非虚拟机运行数据区
- JDK的NIO类可以使用Native函数库直接分配堆外内存，也会出现OOM

---
## *2.虚拟机对象探秘*
- 对象的创建
  - 虚拟机遇到字节码new指令时的处理过程——第七章详解
- 对象的布局
  - *对象头(Header)*
  - *实例数据(InstanceData)*

---
## *3.OOM异常*
- 分析OOM
  - 确认是*内存泄漏(Memory Leak)* 还是*内存溢出(Menory OverFlow)* ，分析内存映像。
  - 扩展虚拟机内存设置
  - 检查代码问题
- 虚拟机栈和本地方法栈溢出
  - 制造溢出场景的方法：减少栈内存容量并通制造大量本地变量，增大次方法帧中的变量表长度2.使用默认参数时，HotSpot虚拟机的栈深度一般可以达到1000~2000
- 方法区和运行时常量池溢出