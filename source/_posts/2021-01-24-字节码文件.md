---
title: 字节码文件
date: 2021-01-24 11:20:00
tags:
- JVM
- Java
categories: article
---
### **前言**
字节码文件是Java程序运行的载体，想要理解Java程序运行的原理，了解字节码文件的内容是重要的一步。最近小小地研究了一下字节码文件中究竟有什么奥秘。
<!--more-->
### **查看字节码**
使用javap对class文件进行反编译，即可查看字节码文件的内容
或者使用vscode中的HexDump插件，可以直接以十六进制的形式查看原始的二进制字节码文件

### **字节码文件格式**
字节文件中包含魔数、次版本号、主版本号、常量池、常量池


### **魔数与版本号**
魔数唯一的作用是识别文件是否是一个能被JVM接受的Class文件。次版本号和主版本号都是用于识别当前的JDK版本。高版本JDK能向下兼容旧版本的Class文件。


### **常量池与常量池容量**
常量池用于存储字面量（Literal）和符号引用（SymbolicReferences）。

#### **字面量**
字面量接近于Java语言层面的常量概念，如文本字符串、声明为final的常量值等。

#### **符号引用**
符号引用包括下面三类常量
* 类与接口的全限定名（Fully Qualified Name）
* 字段的名称和描述符（Descriptor）
* 方法的名称和描述符

常量池中的每一项常量都是一中类似列表的数据结构，其首位存储标志位，用于标记是什么类型的常量，紧接着的数据由不同的常量结构来决定
![常量池的项目类型.png](https://i.loli.net/2021/01/24/csgbqB7AJWDi5e8.png)
常量池中存储的信息有：
* 各类型基本及字符串数据字面量
* 字段、类、接口、字段或方法的部分符号引用
* 方法句柄
* 方法类型标识
* 动态方法调用点

这里有几个点可以关注一下：
1. CONSTANT_String_info常量标识String的字面量，其结构大致可表示如下：
```
CONSTANT_String_info {  
   u1 tag;  
   u2 string_index;  
} 
```
其并不直接存储字符串数据，只保存了常量池索引，索引会指向另一个CONSTANT_Utf8_info常量，这个才是存储字符串数据的常量。

2. CONSTANT_Utf8_info常量的结构大致可表示如下：
```
CONSTANT_Utf8_info {
    u1 tag;
    u2 length;
    u1 bytes;
    u1 bytes;
    u1 bytes;
    .
    .
    .(bytes数据有length个)
}
```
length值说明了这个UTF-8编码的字符串长度是多少字节，它后面紧跟着的长度为length字节的连续数据是一个使用UTF-8缩略编码表示的字符串。
由于Class文件中方法、字段等都需要引用CONSTANT_Utf8_info型常量来描述名称，故CONSTANT_Utf8_info型常量的最大长度就是Java中方法、字段名的最大长度。又由于u2类型能表达的最大值为65535，所以Java程序中定义了超过64KB英文字符的变量或方法名，将会无法编译。
同理，由字符串字面量的定义可知，在编译期，理论上字符串长度最大为65535，而由于javac程序的范围判断（具体可查看javac源码，是>与>=的区别），最大长度实际上是65534。

### **访问标志(access_flags)**
在常量池结束后的数据是访问标志，用于标识类或接口层层的访问信息，比如这个Class是接口还是类，是否定义为public，是否定义为abstract等。

### **类索引、父类索引与接口索引集合**
用来描述类的继承信息的数据，索引会指向常量池，找出对应的类名、接口名、父类名（均为全限定名）

### **字段表集合(field_info)**
用于描述接口或类中声明的变量的数据，其中包括变量的作用域、是实例变量还是类变量（static）、可变性（final）、并发可见性（violatile）、可否被序列化（transient）、字段数据类型、字段名称等。
![字段表结构.png](https://i.loli.net/2021/01/24/n4aNBHq8TLgQYzZ.png)
access_flags是描述符列表，name_index和descriptior_index都是对常量池的引用，分别代表字段的简单名称和描述符。描述符的作用是用来描述字段的数据类型、方法的参数列表和返回值。

### **方法表集合（method_info）**
方法表集合与字段表集合的声明方式几乎一致，只是方法不能用volatile修饰和transient修饰，所以方法表集合中的access_flags中不会出现这两个标志，与之对应的是多了synchronized、abstract标志。
